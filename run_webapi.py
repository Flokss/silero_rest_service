
# ----------

from fastapi import FastAPI, HTTPException
from starlette.responses import Response
import uvicorn
import multiprocessing

app = FastAPI()

version = "1.0"

model = None

@app.on_event("startup")
async def startup_event():
    global model
    modelurl = 'https://models.silero.ai/models/tts/ru/v4_ru.pt'

    import os
    import torch

    device = torch.device('cpu')
    torch.set_num_threads(1)
    local_file = 'silero_model.pt'

    if not os.path.isfile(local_file):
        print("Downloading Silero model...")
        torch.hub.download_url_to_file(modelurl,
                                       local_file)


    model = torch.package.PackageImporter(local_file).load_pickle("tts_models", "model")
    model.to(device)


@app.get(
    "/getwav",

    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses = {
        200: {
            "content": {"audio/wav": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response
)
async def getwav(text_to_speech:str, speaker:str="xenia", sample_rate:int=24000, put_accent:int = 1, put_yo:int = 1):
    """
       Return WAV file with rendered text

       :param str text_to_speech: Текст для озвучки

       :param str speaker: One of speakers name

       :param int sample_rate: Sample rate to generation

       :param int put_accent: 1/0, 1 - простановка акцентов в тексте

       :param int put_yo: 1/0, 1 - простановка Ё в тексте

       :return: WAV file
       """
    import os

    wavfile = "temp.wav"
    path = model.save_wav(text=text_to_speech,
                               speaker=speaker,
                               put_accent=(put_accent==1),
                               put_yo=( put_yo==1),
                               sample_rate=sample_rate)

    # перемещаем wav на новое место
    # if os.path.exists(wavfile):
    #     os.unlink(wavfile)
    # os.rename(path, wavfile)

    in_file = open(path, "rb") # opening for [r]eading as [b]inary
    data = in_file.read() # if you only wanted to read 512 bytes, do .read(512)
    in_file.close()

    return Response(content=data, media_type="audio/wav")



if __name__ == "__main__":
    multiprocessing.freeze_support()
    print("Running silero_rest_service server v{0}...".format(version))
    uvicorn.run("run_webapi:app", host="0.0.0.0", port=5010, log_level="info")
